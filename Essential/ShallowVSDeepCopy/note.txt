ğŸ”¥ Shallow Copy vs. Deep Copy in JavaScript
When working with objects in JavaScript, sometimes you need to copy them. However, there are two types of copies:

Shallow Copy ğŸŠâ€â™‚ï¸ â†’ Copies only the first level of properties. Nested objects remain linked to the original.
Deep Copy ğŸŒŠ â†’ Creates a completely new, independent copy, including nested objects.
1ï¸âƒ£ Shallow Copy using Object.assign()
ğŸ”¹ Object.assign(target, source) creates a shallow copy of an object.
ğŸ”¹ It only copies primitive values (e.g., numbers, strings), but nested objects/arrays are still referenced.

âœ… Example of Object.assign()
javascript
Copy
Edit
let original = {
  name: "Alice",
  details: { age: 25, city: "New York" } // Nested object
};

let shallowCopy = Object.assign({}, original);

// Modify shallow copy
shallowCopy.name = "Bob"; // âœ… Changes only the copy
shallowCopy.details.age = 30; // âŒ Also changes `original.details.age`!

console.log(original.details.age); // 30 âŒ (Unexpected!)
console.log(shallowCopy.details.age); // 30
ğŸ”¹ Why is this happening?
Object.assign() copies primitive properties (name), so "Alice" remains independent.
However, details is a nested object, so only the reference is copied.
Any changes to shallowCopy.details also modify the original.
ğŸ“Œ When to Use?
âœ… If the object doesnâ€™t contain nested structures, Object.assign() is fine.
âŒ If the object has nested objects/arrays, it wonâ€™t fully copy them.

2ï¸âƒ£ Deep Copy using JSON.parse(JSON.stringify(obj))
ğŸ”¹ This method creates a completely independent copy of the original object, including all nested properties.
ğŸ”¹ It converts the object to a JSON string and then parses it back into a new object.

âœ… Example of Deep Copy
javascript
Copy
Edit
let original = {
  name: "Alice",
  details: { age: 25, city: "New York" } // Nested object
};

let deepCopy = JSON.parse(JSON.stringify(original));

// Modify deep copy
deepCopy.details.age = 30; // âœ… Only affects `deepCopy`

console.log(original.details.age); // 25 âœ… (Original remains unchanged)
console.log(deepCopy.details.age); // 30
ğŸ”¹ Why is this better?
This breaks all references between the original and copied object.
Nested objects and arrays are fully copied, not just referenced.
ğŸ“Œ When to Use?
âœ… When you need a completely independent copy of an object.
âŒ Doesnâ€™t work with functions, undefined, or special objects like Date.

ğŸ”¥ Summary Table: Shallow vs. Deep Copy
Feature	Shallow Copy (Object.assign())	Deep Copy (JSON.parse(JSON.stringify()))
Copies first-level properties	âœ… Yes	âœ… Yes
Copies nested objects?	âŒ No (only references copied)	âœ… Yes (fully copied)
Affects original when nested object is modified?	âœ… Yes	âŒ No
Works with all data types?	âœ… Yes (except nested objects)	âŒ No (loses functions, Date, undefined)
Performance	âš¡ Fast	ğŸ¢ Slower (converts to JSON)
ğŸš€ Alternative for Advanced Deep Copies
For better deep copies that support functions, dates, and special objects, use Lodashâ€™s cloneDeep():

javascript
Copy
Edit
const _ = require('lodash');
let deepCopy = _.cloneDeep(original);
âœ… Supports functions, Date, and other special objects.
âœ… More reliable for complex structures.